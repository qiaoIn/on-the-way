#+TITLE: Summary on Column1
#+AUTHOR: qiaoin
#+EMAIL: qiao.liubing@gmail.com
#+OPTIONS: toc:3 num:nil
#+STARTUP: showall
#+DATE: 2018-04-07 21:39:49 [start] 

当被问及一个问题时，“如何给磁盘上的一个文件进行排序？”，我们总是会基于先前已掌握的知识，凭着自
己的定式思维，给出最为直接的反应，

“实现一个给磁盘上文件进行排序的归并排序算法就可以了啊，在一本特别经典的算法编程书籍就有给出如何
实现这样的归并排序算法，用大概两百行左右的代码实现了几个功能函数，你可以找来看看，你可能需要花费
一个星期左右的时间来实现并调试通过吧。”

我们会像这样夸夸其谈，但真的是这样的么？我们真的理解了提问者所提出的问题么？或者，换句话来说，提
问者有清晰地表述出他想要问的问题么？这就像在面试中，面试官会有意或无意的将问题描述的很模糊，考察
你是否有注意到问题的症结所在，并就这一症结提出更为细节的问题。对于“如何给磁盘上的一个文件进行排
序？”，仍有很多未明了的问题。下面是提问者和作者（A 和 B）的对话。

A: 该如何对磁盘上的文件进行排序呢？

B: 需要排序的内容是什么呢？待排序的文件中有多少条记录呢？另外，每条记录的格式是怎么样的？

A: 该文件包含至多 10,000,000 条记录，每条记录都是一个 7 位整数（十进制）。

B: 如果文件这么小，为什么要使用磁盘进行排序呢？为什么不直接在主存中对其进行排序呢？ *注：* “
*文件这么小* ”，最多 10M 条记录，每个记录保存为一个 32-bit 的整数即可，大概需要 40MB 的内存

A: 该功能是某一大型系统的一部分，只能够提供大概 1MB 主存给此功能使用。

B: 你能将每条记录描述的更为详细一些么？

A: 每条记录是一个 7 位的十进制正整数，没有其他相关联的数据，并且每个整数至多只能出现一次。

经过一系列的问题，我们可以为一个描述模糊不清的问题给出更加清晰严谨的问题定义：
#+BEGIN_QUOTE
输入：所输入的是一个文件，至多包含 n 个正整数，每个正整数都小于 n（ n = 10^7）。如果输入文件中，
某一个整数出现了两次，就会产生一个致命错误。这些整数没有其他相关联的数据。

输出：以递增的顺序输出经排序后的整数列表，保存在一磁盘文件中。

约束条件：大概仅有 1MB 的可用主存，但磁盘空间充足。运行时间不能超过几分钟。
#+END_QUOTE

考虑一般的解法，依照能够使用的主存大小（1MB），多次（40 次）读入待排序文件，每次处理待排序文件的
不同部分，使用快速排序算法进行排序，但读取磁盘上文件是非常耗时的一项操作。考虑到实际 n 的大小限制
和每个整数最多只能够出现一次的限制，而所谓的排序也只是把文件中的整数按照其在 [0, n) 内出现的顺序
进行输出而已，因此只要对 [0, n) 之内出现的整数做一下标记，最后按所需要的顺序输出标记过的整数就可
以了。鉴于此，位向量（或称位图，bit vector or bitmap）就是比较合适的数据结构了，每个位上的0/1
值就表示这个数字是否在待排序文件中出现过，实现的时间复杂度是 O(n)，空间复杂度是 O(n)，n 的最大
取值为 10^7，所需要的内存空间为 10^7 / 8 / 2^10 / 2^10 = 1.25MB 左右。这里我们之所以能够
使用位图这样的数据结构来进行数据表示，是基于这个问题的特殊性，1.输入数据来自于一个相对较小的范围；
2.没有重复数据，数据最多出现一次；3.每条记录都没有附加数据，而这些特殊性在一般的排序中是很难满足
的。基于位图数据结构的表示方法，磁盘文件的排序可以用三步来实现：
- phase 1: 初始化所有的位为 0；
- phase 2: 读取文件中的每个整数，将相对应的位置 1；如果该整数对应的位已经为 1，说明前面已经出现过这个整数，抛出异常，退出程序；
- phase 3: 检查每个位，如果某个位是 1，输出对应的整数，从而创建已排序的输出文件。

在解决这个实际问题的方案中，我们看到了不同于比较排序的一种排序方式：使用位图进行排序，从这个问题
出发，引出了作者的一些思考和对我们读者的一些启示：
- The right problem. \\ 
  如何提问，如何清晰的进行问题描述，有点类似与软件工程中的需求分析，其重要性不容质疑，我们只有在
清楚要解决的是什么问题，厘清该问题的各个细节之后，才能够找到问题的解法和优化解。
- 位图数据结构。 \\ 
  使用位图进行表示是基于一些约束的，集合是稠密的（相比于稀疏），所有的数据分布
在一个有限的范围内，集合中的每一个元素都是唯一的，并且没有相关联的额外的数据。Even if these 
conditions aren't satisfied (when there are multiple elements or extra data,
for instance), a key from a finite domain can be used as an index into a table
with more complicated entries. 这句话怎么理解？
- 时间和空间是可以双赢的。 \\
  确实，在很多时候我们会在时间和空间之间做出折中（ tradeoffs ）的选择，
但是有些时候，当我们减少一个程序所使用的空间时，执行此程序所需要的时间也会跟着就减少了，从而达到
空间和时间上的双赢。像给磁盘文件进行排序这个问题，当我们使用位图来进行表示，使用的空间急剧缩减
O(n)，同时执行时间也为 O(n)。使用位图进行表示，更少的数据，对应的操作也会减少，由于占用空间少，
就能将数据整个的载入到主存中，减少了对磁盘进行访问的耗费。
- 简单的设计。 \\ 
  “设计者确定其设计已经达到完美的标准，不是不能再增加任何东西，而是不能再减少任何东
西”，在满足要求的前提下尽量让设计简洁，这样会更 reliable, secure, robust and efficient，
并且有利于代码的创建和维护。“大道至简”，设计需要的也许更多的是简洁性。

未明白的问题：
- A Merge Sort program reads the file once from the input, sorts it with the aid of
work files that are read and written many times, and then writes it once.

  这一段的描述应该如何理解，另外这里提及的 *a general disk-based Merge Sort* 算法怎么实现？

Problems: *TODO*



